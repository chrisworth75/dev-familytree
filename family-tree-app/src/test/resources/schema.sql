-- H2 Test Schema (PostgreSQL compatibility mode)
-- Minimal CREATE TABLE statements for testing

-- ============================================
-- TABLES
-- ============================================

CREATE TABLE tree (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255),
    slug VARCHAR(100),
    source VARCHAR(100),
    owner_name VARCHAR(255),
    ancestry_tree_id BIGINT,
    size INT DEFAULT 0,
    dna_test_id VARCHAR(36),
    notes CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE person (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    first_name VARCHAR(500),
    middle_names VARCHAR(500),
    surname VARCHAR(255),
    birth_surname VARCHAR(255),
    birth_date DATE,
    birth_place VARCHAR(255),
    death_date DATE,
    death_place VARCHAR(255),
    gender CHAR(1),
    father_id INT,
    mother_id INT,
    notes CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    birth_year_approx INT,
    death_year_approx INT,
    tree_id INT,
    dna_test_id VARCHAR(36),
    tree_person_id BIGINT,
    avatar_path VARCHAR(255),
    CONSTRAINT fk_person_father FOREIGN KEY (father_id) REFERENCES person(id),
    CONSTRAINT fk_person_mother FOREIGN KEY (mother_id) REFERENCES person(id),
    CONSTRAINT fk_person_tree FOREIGN KEY (tree_id) REFERENCES tree(id)
);

CREATE TABLE partnership (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    person_1_id INT NOT NULL,
    person_2_id INT NOT NULL,
    marriage_date DATE,
    marriage_date_approx BOOLEAN DEFAULT FALSE,
    marriage_place VARCHAR(255),
    notes CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_partnership_person_1 FOREIGN KEY (person_1_id) REFERENCES person(id),
    CONSTRAINT fk_partnership_person_2 FOREIGN KEY (person_2_id) REFERENCES person(id),
    CONSTRAINT uk_partnership UNIQUE (person_1_id, person_2_id)
);

CREATE TABLE person_url (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    person_id INT NOT NULL,
    url VARCHAR(1000) NOT NULL,
    description VARCHAR(255),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_person_url_person FOREIGN KEY (person_id) REFERENCES person(id)
);

CREATE TABLE source_record (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    record_type VARCHAR(50) NOT NULL,
    title VARCHAR(500),
    record_date DATE,
    record_date_approx BOOLEAN DEFAULT FALSE,
    location VARCHAR(255),
    reference VARCHAR(255),
    url VARCHAR(1000),
    data CLOB,
    notes CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE person_source (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    person_id INT NOT NULL,
    source_record_id INT NOT NULL,
    role VARCHAR(50) NOT NULL,
    confidence VARCHAR(20),
    notes CLOB,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_person_source_person FOREIGN KEY (person_id) REFERENCES person(id),
    CONSTRAINT fk_person_source_record FOREIGN KEY (source_record_id) REFERENCES source_record(id),
    CONSTRAINT uk_person_source_role UNIQUE (person_id, source_record_id, role)
);

CREATE TABLE cluster (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    name VARCHAR(255),
    notes CLOB,
    ahnentafel_1 INT,
    ahnentafel_2 INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

CREATE TABLE ancestor (
    ahnentafel INT PRIMARY KEY,
    person_id INT NOT NULL UNIQUE,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_ancestor_person FOREIGN KEY (person_id) REFERENCES person(id)
);

CREATE TABLE ancestry_tester (
    dna_test_id VARCHAR(36) PRIMARY KEY,
    name VARCHAR(500) NOT NULL,
    source VARCHAR(50) DEFAULT 'ancestry',
    admin_level INT,
    has_tree BOOLEAN DEFAULT FALSE,
    tree_size INT,
    notes CLOB,
    person_id INT,
    generation_depth INT,
    avatar_path VARCHAR(255),
    primary_cluster_id INT,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_ancestry_tester_person FOREIGN KEY (person_id) REFERENCES person(id),
    CONSTRAINT fk_ancestry_tester_cluster FOREIGN KEY (primary_cluster_id) REFERENCES cluster(id)
);

CREATE TABLE ancestry_dna_match (
    tester_1_id VARCHAR(36) NOT NULL,
    tester_2_id VARCHAR(36) NOT NULL,
    shared_cm DECIMAL(8,3),
    shared_segments INT,
    predicted_relationship VARCHAR(100),
    match_side VARCHAR(20),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (tester_1_id, tester_2_id),
    CONSTRAINT fk_dna_match_tester_1 FOREIGN KEY (tester_1_id) REFERENCES ancestry_tester(dna_test_id),
    CONSTRAINT fk_dna_match_tester_2 FOREIGN KEY (tester_2_id) REFERENCES ancestry_tester(dna_test_id),
    CONSTRAINT chk_match_order CHECK (tester_1_id < tester_2_id),
    CONSTRAINT chk_match_side CHECK (match_side IN ('paternal', 'maternal', 'both', 'unknown'))
);

CREATE TABLE match_cluster (
    id INT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
    dna_test_id VARCHAR(36) NOT NULL,
    cluster_id INT NOT NULL,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    CONSTRAINT fk_match_cluster_tester FOREIGN KEY (dna_test_id) REFERENCES ancestry_tester(dna_test_id),
    CONSTRAINT fk_match_cluster_cluster FOREIGN KEY (cluster_id) REFERENCES cluster(id),
    CONSTRAINT uk_dna_test_cluster UNIQUE (dna_test_id, cluster_id)
);

-- Add FK for tree.dna_test_id after ancestry_tester exists
ALTER TABLE tree ADD CONSTRAINT fk_tree_dna_test FOREIGN KEY (dna_test_id) REFERENCES ancestry_tester(dna_test_id);
